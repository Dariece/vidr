package de.daniel.marlinghaus.vidr.vulnerability.resolve.vo;

import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.CvssSeverity;
import java.util.Iterator;
import lombok.AccessLevel;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;
import org.gradle.api.internal.artifacts.dependencies.DefaultExternalModuleDependency;

/**
 * Representation of a vulnerable dependency
 */
@EqualsAndHashCode(callSuper = true)
@SuperBuilder
@Data
public class VulnerableDependency extends GavDependency{ //TODO extends DependencyModel/ DefaultExternalModuleDependency

  /**
   * Version to fix vulnerability of Dependency
   */
  private String fixVersion;
  private CvssSeverity severity;

  /**
   * Dependency version number
   */
  private CustomVersionNumber versionNumber;

  /**
   * Version number to fix vulnerability of Dependency
   */
  private CustomVersionNumber fixVersionNumber;

  @Getter(AccessLevel.NONE)
  @EqualsAndHashCode.Exclude
  @ToString.Exclude
  private Iterator<CustomVersionNumber> alternativeFixVersions;

  public Boolean nextFixVersion() {
    if (alternativeFixVersions != null && alternativeFixVersions.hasNext()) {
      CustomVersionNumber next = alternativeFixVersions.next();
      setFixVersionNumber(next);
      setFixVersion(next.toString());
      return true;
    }
    return false;
  }

  public Boolean isSameFixGAV(String group, String name, String version) {
    return getGroup().equals(group) && getName().equals(name) && getFixVersion().equals(version);
  }

  public Boolean isSpringBootDependency() {
    return this.getGroup().equals("org.springframework.boot");
  }

  public DefaultExternalModuleDependency copyFix() {
    return new DefaultExternalModuleDependency(getGroup(), getName(), getFixVersion());
  }

  //TODO liste mit möglichen anderen Fixversionen für Kompatibilitätsbeheber
}
