package de.daniel.marlinghaus.vidr.vulnerability.resolve;

import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.vulnerability.report.VulnerabilityReportDeserializer;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.Vulnerability;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.VulnerableDependency;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.factory.Sets;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.multimap.ImmutableMultimap;
import org.eclipse.collections.api.partition.set.PartitionImmutableSet;

/**
 * resolves the fix versions for each dependency included in the vulnerabilities of the report
 *
 * @param <T> Implementation of reportDeserializer for example TrivyReportDeserializer
 */
@RequiredArgsConstructor
public class VulnerableDependencyFixVersionResolver<T extends VulnerabilityReportDeserializer> {

  @Getter
  private List<VulnerableDependency> fixableDependencies = new ArrayList<>();
  @Getter
  private List<VulnerableDependency> unfixableDependencies = new ArrayList<>();
  @Getter
  private List<VulnerableDependency> fixedByOtherDependencies = new ArrayList<>();
  @Getter
  private List<Vulnerability> unfixableVulnerabilities = new ArrayList<>();

  private final T reportDeserializer;

  /**
   * resolves the fix versions for each dependency included in the vulnerabilities of the report
   *
   * @param report vulnerabilites from report with cve and dependency (as packageName) to be fixed
   * @return list of fixed dependencies (may differ from fixable list)
   */
  public List<VulnerableDependency> resolveFixVersions(
      List<Vulnerability> report) { //eher dertmine fixable vulnerability dependencies

    //TODO unfixable vulnerabilities behandeln/loggen/reporten
    //partitioniere zwischen fixable und unfixable dependencies
    //use set to remove possible vulnerability duplicates
    PartitionImmutableSet<Vulnerability> partitionVulnerabilities = Sets.immutable.ofAll(report)
        .partition(Vulnerability::isFixable);
    unfixableDependencies.addAll(reportDeserializer.extractVulnerableDependencies(
        partitionVulnerabilities.getRejected().toList()));
    unfixableVulnerabilities.addAll(partitionVulnerabilities.getRejected().toList());

    //cluster vulnerabilities with same dependency
    //use multimap because its faster to find O(n) than using basic java imperative nested loop O(n²)
    ImmutableMultimap<String, Vulnerability> clusteredVulnerabilities = partitionVulnerabilities.getSelected()
        .groupBy(Vulnerability::getDependencyName);

    //operate on vulnerability set for each dependency name
    for (var key : clusteredVulnerabilities.keySet()) {

      //filtere vulnerabilities auf severity >= HIGH,
      MutableList<Vulnerability> sortedFilteredVulnerabilities = clusteredVulnerabilities.get(key)
          .select(
              Vulnerability::checkSeverityIsHigherThanMedium) //TODO severity konfigurierbar machen. Entweder hier oder schon bei der report generierung
          //sortiere nach größe aufsteigend, Severity hat das höchste Gewicht, die Aktualität der Fixversion ist das zweite Indiz
          .toSortedListBy(v -> (v.getSeverity().ordinal() * 100) + v.getMaxFixVersion().toString());

      if (!sortedFilteredVulnerabilities.isEmpty()) {

        //filtere die größte fix version von jeder vulnerability
        MutableList<CustomVersionNumber> maxFixedVersions = sortedFilteredVulnerabilities.collect(
            Vulnerability::getMaxFixVersion);

        var vulnerabilityWithHighestSeverity = sortedFilteredVulnerabilities.getLastOptional()
            .orElseThrow();
        //alle Fix-Versionen der Sicherheitslücke mit der höchsten Severity hinzufügen
        maxFixedVersions.addAll(Lists.mutable.ofAll(
            vulnerabilityWithHighestSeverity.getFixedVersionNumbers()));

        //sortiere nach größe aufsteigend, entferne Duplikate
        maxFixedVersions = maxFixedVersions.distinct().sortThis(CustomVersionNumber::compareTo);

        //nehme critical vulnerability als aktuelle referenz,
        var actualVersionNumber = vulnerabilityWithHighestSeverity.getActualVersionNumber();
        Iterator<CustomVersionNumber> versionNumberIterator = maxFixedVersions.select(
            maxVersion -> {
              //nehme die erste version die größer ist als die aktuelle,
              return maxVersion.compareTo(actualVersionNumber) > 0
                  //vergleiche ob die version in fixes mit der höchsten severity vorkommt,
//          && vulnerabilityWithHighestSeverity.getFixedVersionNumbers().contains(maxVersion) //TODO de-comment after testing
                  ;
            }).asReversed().iterator();
        CustomVersionNumber fixedVersion = versionNumberIterator.next();

        //sonst nehme hier die nächst größere fix version im Vergleich zu der aktuellen version
//        if (fixedVersion == null) { //Fixme workaround wenn nicht alle fixVersions der Dependency mit der höchsten Severtity vorhanden sind
//          fixedVersion = vulnerabilityWithHighestSeverity.getFixedVersionNumbers()
//              .detect(vn -> vn.compareTo(actualVersionNumber) > 0);
//        }

        //erstelle dependency mit reportDeserializer
        VulnerableDependency vulnerableDependency = reportDeserializer.extractVulnerableDependency(
            vulnerabilityWithHighestSeverity,
            fixedVersion, fixedVersion.toString());
        vulnerableDependency.setAlternativeFixVersions(versionNumberIterator);
        fixableDependencies.add(vulnerableDependency);
      }
    }
    removeTransitiveSpringDependencies();
    //TODO in incompatibility resolver nochmal darauf achten dass framework libraries die gleiche Version haben
    //TODO fixableDependencies nach fixVersion sortieren, damit größte springBoot Version zuerst genommen wird
    //Direkte Dependencies zuerst fixen, dann transitive
    return fixableDependencies;
  }

  /**
   * Workaround for spring framework dependencies
   */
  //alternatively use https://docs.gradle.org/current/userguide/dependency_version_alignment.html#sec:align-versions-unpublished
  private void removeTransitiveSpringDependencies() {
    fixableDependencies.removeIf(
        removeDependency -> {
          Optional<VulnerableDependency> searchResult = Sets.immutable.ofAll(
              fixableDependencies).detectOptional(
              searchDependency -> removeDependency.getGroup().equals("org.springframework")
                  && searchDependency.getGroup().equals("org.springframework.boot")
//                && searchDependency.getName().endsWith(removeDependency.getName().split("-", 2)[1])
          );
          searchResult.ifPresent(
              gavVulnerableDependency -> this.fixedByOtherDependencies.add(removeDependency));
          return searchResult.isPresent();
        });
  }

  public void resolveVulnerarbleDependencyFixes(List<VulnerableDependency> fixableDependencies) {
    //ändere die versionen der betroffenen dependencies auf die gefixten

    //gemeinsame Version bei Frameworks z. B. gemeinsame Group org.springframework beachten
    //baue das projekt mit den geänderten Versionen oder erstelle neue sbom, je nach implementierung für prüfung
    //was wenn nicht baubar? Kann Plugin weiterlaufen?
  }
}
