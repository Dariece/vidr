package de.daniel.marlinghaus.vidr.vulnerability.report.vo;

import com.fasterxml.jackson.annotation.JsonIgnore;
import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.VulnerableDependency;
import java.util.List;
import javax.annotation.concurrent.Immutable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.ImmutableList;

@SuperBuilder
@Immutable
@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public abstract class Vulnerability {

  //deserialized fields
  String cveId;
  String cveTitle;
  CvssSeverity severity;
  String actualVersion;
  List<String> fixedVersions;
  String dependencyName;

  //processed fields
  @JsonIgnore
  private VulnerableDependency vulnerableDependency;

  //caches
  //to prevent multiple unnecessary calculation
  @Getter(AccessLevel.PROTECTED)
  @Setter(AccessLevel.PROTECTED)
  @JsonIgnore
  private CustomVersionNumber maxFixVersionNumberCache;

  @Getter(AccessLevel.PROTECTED)
  @Setter(AccessLevel.PROTECTED)
  @JsonIgnore
  private ImmutableList<CustomVersionNumber> fixedVersionNumbersCache;

  @Getter(AccessLevel.PROTECTED)
  @Setter(AccessLevel.PROTECTED)
  @JsonIgnore
  private CustomVersionNumber actualVersionNumbersCache;

  //processing methods

  /**
   * Can the vulnerability be fixed or not (fixed version available? Has known severity?)
   * <p>Hint: Needs additional condition for incompatibility; dependency name determinable?.</p>
   *
   * @return Can the vulnerability be fixed or not
   */
  public Boolean isFixable() {
    return !getFixedVersions().isEmpty() && !CvssSeverity.UNKNOWN.equals(getSeverity());
  }

  private static CustomVersionNumber getVersionNumber(String versionString) {
    return CustomVersionNumber.parse(versionString);
  }

  /**
   * @return the biggest fix version
   */
  public CustomVersionNumber getMaxFixVersion() {
    if (this.getMaxFixVersionNumberCache() == null) {
      this.setMaxFixVersionNumberCache(
          getFixedVersionNumbers().max(CustomVersionNumber::compareTo));
    }
    return this.getMaxFixVersionNumberCache();
  }

  /**
   * @return actual version as CustomVersionNumber object
   */
  public CustomVersionNumber getActualVersionNumber() {
    if (this.getActualVersionNumbersCache() == null) {
      this.setActualVersionNumbersCache(getVersionNumber(getActualVersion()));
    }

    return this.getActualVersionNumbersCache();
  }

  /**
   * @return all fixed versions as gradle CustomVersionNumber
   */
  public ImmutableList<CustomVersionNumber> getFixedVersionNumbers() {
    if (this.getFixedVersionNumbersCache() == null) {
      this.setFixedVersionNumbersCache(Lists.immutable.ofAll(getFixedVersions())
          .collect(Vulnerability::getVersionNumber));
    }

    return this.getFixedVersionNumbersCache();
  }

  /**
   * Checks if severity of vulnerability is higher than medium
   *
   * @param vulnerability to be checked
   * @return condition is true or false
   */
  public static boolean checkSeverityIsHigherThanMedium(Vulnerability vulnerability) {
    return vulnerability.getSeverity().ordinal() > CvssSeverity.MEDIUM.ordinal();
  }
}
