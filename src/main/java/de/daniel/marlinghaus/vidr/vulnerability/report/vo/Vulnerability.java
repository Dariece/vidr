package de.daniel.marlinghaus.vidr.vulnerability.report.vo;

import com.fasterxml.jackson.annotation.JsonIgnore;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.GavVulnerableDependency;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Builder.Default;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import lombok.experimental.SuperBuilder;
import org.eclipse.collections.api.list.ImmutableList;
import org.gradle.util.internal.VersionNumber;

@SuperBuilder
@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public abstract class Vulnerability {

  //deserialized fields
  private String cveId;
  private String cveTitle;
  private CvssSeverity severity;
  private String actualVersion;
  @Builder.Default
  private List<String> fixedVersions = new ArrayList<>();
  private String dependencyName;

  //processed fields
  /**
   * Can the vulnerability be fixed or not (fixed version available? Has known severity?)
   * <p>Hint: Needs additional condition for incompatibility; dependency name determinable?.</p>
   */

  public Boolean isFixable(){
    return !fixedVersions.isEmpty() && !CvssSeverity.UNKNOWN.equals(severity);
  }

  @JsonIgnore
  private GavVulnerableDependency gavVulnerableDependency;

  public boolean isSameDependency(Vulnerability compare) {
    return dependencyName.equals(compare.getDependencyName());
  }

  /**
   * @return the biggest fix version
   */
  public VersionNumber getMaxFixVersion() {
    return fixedVersions.stream().map(VersionNumber::parse).max(VersionNumber::compareTo)
        .orElseThrow();
  }

  //TODO fix multiple call of parse in business logic
  public VersionNumber getActualVersionNumber(){
    return VersionNumber.parse(actualVersion);
  }
  /**
   * @return all fixed versions as gradle versionNumber
   */
  public ImmutableList<VersionNumber> getFixedVersionNumbers(){
    return ((ImmutableList<String>) fixedVersions).collect(VersionNumber::parse);
  }


  /**
   * Checks if severity of vulnerability is higher than medium
   * @param vulnerability to be checked
   * @return condition is true or false
   */
  public static boolean checkSeverityIsHigherThanMedium(Vulnerability vulnerability) {
    return vulnerability.getSeverity().ordinal() > CvssSeverity.MEDIUM.ordinal();
  }

}
