package de.daniel.marlinghaus.vidr.vulnerability.report;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.utils.configuration.JsonConfiguration;
import de.daniel.marlinghaus.vidr.utils.string.StringUtils;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.VulnerabilityReport;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.trivy.TrivyReport;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.trivy.TrivyVulnerability;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.VulnerableDependency;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import org.gradle.api.GradleException;

public class TrivyReportDeserializer implements
    VulnerabilityReportDeserializer<TrivyVulnerability> {

  private OutputStream reportFile;
  private final ObjectMapper objectMapper = JsonConfiguration.jsonMapper();

  @Override
  public VulnerabilityReport<TrivyVulnerability> deserialize(Path report) throws IOException {
    if (objectMapper.canDeserialize(objectMapper.constructType(TrivyVulnerability.class))) {
      return objectMapper.<TrivyReport>readValue(report.toFile(),
          new TypeReference<>() {
          });
    } else {
      throw new GradleException(
          "TrivyVulnerability can't be deserialized");//TODO use custom exception
    }
  }

  //TODO implement or remove if not needed
  @Override
  public VulnerabilityReport<TrivyVulnerability> deserialize(OutputStream report) {
    return null;
  }

  @Override
  public List<VulnerableDependency> extractVulnerableDependencies(
      List<TrivyVulnerability> vulnerabilities) {
    List<VulnerableDependency> gavVulnerableDependencies = new ArrayList<>();

    vulnerabilities.stream()
        .filter(v -> StringUtils.notBlank(v.getDependencyName())).forEach(
            v -> gavVulnerableDependencies.add(extractVulnerableDependency(v))
        );

    return gavVulnerableDependencies;
  }

  @Override
  public VulnerableDependency extractVulnerableDependency(TrivyVulnerability vulnerability) {
    return extractVulnerableDependency(vulnerability, null, null);
  }

  @Override
  public VulnerableDependency extractVulnerableDependency(TrivyVulnerability vulnerability,
      CustomVersionNumber fixVersionNumber, String fixVersion) {
    String[] packageSplit = vulnerability.getDependencyName().split(":");
    return VulnerableDependency.builder()
        .group(packageSplit[0])
        .name(packageSplit[1])
        .version(vulnerability.getActualVersion())
        .versionNumber(vulnerability.getActualVersionNumber())
        .fixVersion(fixVersion != null ? fixVersion
            : (!vulnerability.getFixedVersions().isEmpty() ? vulnerability.getMaxFixVersion()
                .toString()
                : null))
        .fixVersionNumber(fixVersionNumber != null ? fixVersionNumber
            : (!vulnerability.getFixedVersions().isEmpty() ? vulnerability.getMaxFixVersion()
                : null))
        .severity(vulnerability.getSeverity())
        .dependencyName(vulnerability.getDependencyName())
        .build();
  }


  /**
   * @throws Exception
   */
  @Override
  public void close() throws Exception {
    if (reportFile != null) {
      reportFile.close();
    }
  }
}
