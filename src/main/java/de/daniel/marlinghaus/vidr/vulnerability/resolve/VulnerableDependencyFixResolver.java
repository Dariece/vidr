package de.daniel.marlinghaus.vidr.vulnerability.resolve;

import de.daniel.marlinghaus.vidr.vulnerability.report.VulnerabilityReportDeserializer;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.CvssSeverity;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.Vulnerability;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.GavVulnerableDependency;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.multimap.Multimap;
import org.gradle.internal.impldep.com.google.common.collect.ImmutableListMultimap;
import org.gradle.internal.impldep.com.google.common.collect.ImmutableSet;
import org.gradle.internal.impldep.com.google.common.collect.ImmutableSetMultimap;

@RequiredArgsConstructor
public class VulnerableDependencyFixResolver {

  private List<GavVulnerableDependency> fixableDependencies = new ArrayList<>();

  private final VulnerabilityReportDeserializer<?> reportDeserializer;

  //Hinweis: Inkompatibilitätsbeheber kann die fixes versionen als Orientierung nutzen

  /**
   * @param report vulnerabilites from report with cve and dependency (as packageName) to be fixed
   * @return list of fixed dependencies (may differ from fixable list)
   */
  public List<GavVulnerableDependency> resolveFixes(ImmutableList<Vulnerability> report) {

    //cluster vulnerabilities with same dependency

    //Use multimap because its faster to find O(n) than using nested loop O(n²)
    ImmutableSetMultimap<String, Vulnerability> clusteredVulnerabilities = ImmutableSetMultimap.<String, Vulnerability>builder()
        .putAll(report.collect(v -> Map.entry(v.getDependencyName(), v))).build();
//    ImmutableListMultimap<String, Vulnerability> clusteredVulnerabilities = MutableSortedBagMultimap.<String, Vulnerability>copyOf(report.collect(v -> Map.entry(v.getDependencyName(), v)));

    //filtere die größte fix version von jeder vulnerability mit severity >= HIGH (eventuell alle versionen der neuesten critical severity),
    //sortiere nach größe aufsteigend,
    //nehme die erste version die größer ist als die aktuelle,
    //vergleiche ob die version in fixes mit der höchsten severity vorkommt,
    //sonst nehme hier die nächst größere im Vergleich zu der aktuellen version
    for ( var key : clusteredVulnerabilities.keys()){
      ImmutableSet<Vulnerability> vulnerabilities = clusteredVulnerabilities.get(key).stream().filter(this::severityIsHigherThanMedium).map(v -> {
        var maxVersion = Collections.max(v.getFixedVersions());
        v.setFixedVersions(Lists.mutable.of(maxVersion));
      });

    }

    //erstelle dependencies mit reportDeserializer

    //ändere die versionen der betroffenen dependencies auf die gefixten
    //baue das projekt mit den geänderten versionen oder erstelle neue sbom, je nach implementierung für prüfung
    //was wenn nicht baubar? Kann Plugin weiterlaufen?
    return fixableDependencies;
  }

  boolean severityIsHigherThanMedium(Vulnerability vulnerability){
    return vulnerability.getSeverity().ordinal() > CvssSeverity.MEDIUM.ordinal();
  }

}
