package de.daniel.marlinghaus.vidr.vulnerability.resolve;

import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.vulnerability.report.VulnerabilityReportDeserializer;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.Vulnerability;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.GavVulnerableDependency;
import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.factory.Sets;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.api.multimap.ImmutableMultimap;
import org.eclipse.collections.api.partition.set.PartitionImmutableSet;

@RequiredArgsConstructor
public class VulnerableDependencyFixResolver<T extends VulnerabilityReportDeserializer> {

  @Getter
  private List<GavVulnerableDependency> fixableDependencies = new ArrayList<>();
  @Getter
  private List<GavVulnerableDependency> unfixableDependencies = new ArrayList<>();

  private final T reportDeserializer;

  //TODO Hinweis: Inkompatibilitätsbeheber kann die fixes versionen als Orientierung nutzen

  /**
   * @param report vulnerabilites from report with cve and dependency (as packageName) to be fixed
   * @return list of fixed dependencies (may differ from fixable list)
   */
  public List<GavVulnerableDependency> resolveFixes(List<Vulnerability> report) {

    //TODO unfixable vulnerabilities behandeln/loggen/reporten
    //partitioniere zwischen fixable und unfixable dependencies
    //use set to remove possible vulnerability duplicates
    PartitionImmutableSet<Vulnerability> partitionVulnerabilities = Sets.immutable.ofAll(report)
        .partition(Vulnerability::isFixable);
    unfixableDependencies.addAll(reportDeserializer.extractVulnerableDependencies(
        partitionVulnerabilities.getRejected().toList()));

    //cluster vulnerabilities with same dependency
    //use multimap because its faster to find O(n) than using basic java imperative nested loop O(n²)
    ImmutableMultimap<String, Vulnerability> clusteredVulnerabilities = partitionVulnerabilities.getSelected()
        .groupBy(Vulnerability::getDependencyName);

    //filtere die größte fix version von jeder vulnerability mit severity >= HIGH (eventuell alle versionen der neuesten critical severity),
    //sortiere nach größe aufsteigend,
    //nehme die erste version die größer ist als die aktuelle,
    //vergleiche ob die version in fixes mit der höchsten severity vorkommt,
    //sonst nehme hier die nächst größere im Vergleich zu der aktuellen version

    //operate on vulnerability set for each dependency name
    for (var key : clusteredVulnerabilities.keySet()) {


      //TODO fix order when vulnerabilities with same severity exist
      //filtere vulnerabilities auf severity >= HIGH,
      MutableList<Vulnerability> vulnerabilities = clusteredVulnerabilities.get(key)
          .select(
              Vulnerability::checkSeverityIsHigherThanMedium) //TODO severity konfigurierbar machen. Entweder hier oder schon bei der report generierung
          //sortiere nach größe aufsteigend,
          .toSortedListBy(v -> v.getSeverity().ordinal());

      if (!vulnerabilities.isEmpty()) {

        //filtere die größte fix version von jeder vulnerability
        MutableList<CustomVersionNumber> maxFixedVersions = vulnerabilities.collect(
            Vulnerability::getMaxFixVersion); //TODO eventuell doch alle Versionen verwenden?

        //(eventuell alle versionen der neuesten critical severity)
        var vulnerabilityWithHighestSeverity = vulnerabilities.getLastOptional().orElseThrow();
        maxFixedVersions.addAll(Lists.mutable.ofAll(
            vulnerabilityWithHighestSeverity.getFixedVersionNumbers())); //TODO evaluieren ob ohne zielführender

        //sortiere nach größe aufsteigend,
        maxFixedVersions = maxFixedVersions.distinct().sortThis();

        //nehme critical vulnerability als aktuelle referenz,
        var actualVersionNumber = vulnerabilityWithHighestSeverity.getActualVersionNumber();
        CustomVersionNumber fixedVersion = maxFixedVersions.detect(maxVersion -> {
          //nehme die erste version die größer ist als die aktuelle,
          return maxVersion.compareTo(actualVersionNumber) > 0
              //vergleiche ob die version in fixes mit der höchsten severity vorkommt,
              && vulnerabilityWithHighestSeverity.getFixedVersionNumbers().contains(maxVersion);
        });

        //sonst nehme hier die nächst größere fix version im Vergleich zu der aktuellen version
        if (fixedVersion == null) { //workaround
          fixedVersion = vulnerabilityWithHighestSeverity.getFixedVersionNumbers()
              .detect(vn -> vn.compareTo(actualVersionNumber) > 0);
        }

        //erstelle dependency mit reportDeserializer
        fixableDependencies.add(
            reportDeserializer.extractVulnerableDependency(vulnerabilityWithHighestSeverity,
                fixedVersion, fixedVersion.toString()));
      }
    }

    //TODO in incompatibility resolver nochmal darauf achten dass framework libraries die gleiche Version haben

    //ändere die versionen der betroffenen dependencies auf die gefixten
    //gemeinsame Version bei Frameworks z. B. gemeinsame Group org.springframework beachten
    //baue das projekt mit den geänderten versionen oder erstelle neue sbom, je nach implementierung für prüfung
    //was wenn nicht baubar? Kann Plugin weiterlaufen?
    return fixableDependencies;
  }
}
