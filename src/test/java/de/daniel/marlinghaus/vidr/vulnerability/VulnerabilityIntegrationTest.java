package de.daniel.marlinghaus.vidr.vulnerability;

import static org.assertj.core.api.Assertions.assertThat;

import de.daniel.marlinghaus.vidr.utils.configuration.CustomVersionNumber;
import de.daniel.marlinghaus.vidr.vulnerability.report.TrivyReportDeserializer;
import de.daniel.marlinghaus.vidr.vulnerability.report.VulnerabilityReportDeserializer;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.CvssSeverity;
import de.daniel.marlinghaus.vidr.vulnerability.report.vo.Vulnerability;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.VulnerableDependencyFixVersionResolver;
import de.daniel.marlinghaus.vidr.vulnerability.resolve.vo.GavVulnerableDependency;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import org.junit.jupiter.api.Test;

public class VulnerabilityIntegrationTest {

  private final Path reportFile = Paths.get("src", "test", "resources",
      "vulnerability-sbom-test-local-bec7c176-06db-4d76-8247-6686b73d761d-trivy-report.json");

  @Test
  void testVulnerabilityResolve() throws Exception {
    try (VulnerabilityReportDeserializer trivyReportDeserializer = new TrivyReportDeserializer()) {
      var result = trivyReportDeserializer.deserialize(reportFile);
      List<Vulnerability> reportVulnerabilities = result.getVulnerabilities();
      assertThat(result).isNotNull();
      assertThat(result).hasNoNullFieldsOrProperties();
      assertThat(reportVulnerabilities).isNotEmpty();

      VulnerableDependencyFixVersionResolver<TrivyReportDeserializer> vulnerableDependencyFixVersionResolver = new VulnerableDependencyFixVersionResolver(
          trivyReportDeserializer);
      vulnerableDependencyFixVersionResolver.resolveFixVersions(reportVulnerabilities);

      var fixableDependencies = vulnerableDependencyFixVersionResolver.getFixableDependencies();
      var unfixableDependencies = vulnerableDependencyFixVersionResolver.getUnfixableDependencies();
      var fixedByOtherDependencies = vulnerableDependencyFixVersionResolver.getFixedByOtherDependencies();

//      reportVulnerabilities.forEach(v -> {
//        if (!v.getFixedVersionNumbers().isEmpty()) {
//          System.out.println(v.getDependencyName() + ":" + v.getMaxFixVersion());
//        }
//      }); //just debugging
//      System.out.println("Fixable dependencies: " + fixableDependencies); //just debugging
//      System.out.println("Unfixable dependencies: " + unfixableDependencies); //just debugging

      GavVulnerableDependency expectedFixDependency = GavVulnerableDependency.builder()
          .name("jackson-databind").group("com.fasterxml.jackson.core").version("2.13.2")
          .versionNumber(CustomVersionNumber.parse("2.13.2")).fixVersion("2.13.4.1")
          .fixVersionNumber(CustomVersionNumber.parse("2.13.4.1")).severity(CvssSeverity.HIGH)
          .dependencyName("com.fasterxml.jackson.core:jackson-databind").build();
      GavVulnerableDependency expectedUnfixDependency = GavVulnerableDependency.builder()
          .name("spring-boot-starter-web").group("org.springframework.boot").version("2.6.5")
          .versionNumber(CustomVersionNumber.parse("2.6.5"))
          .fixVersionNumber(CustomVersionNumber.parse("2.6.6")).severity(CvssSeverity.UNKNOWN)
          .fixVersion("2.6.6").dependencyName("org.springframework.boot:spring-boot-starter-web")
          .build();
      GavVulnerableDependency expectedFixedByOtherDependency = GavVulnerableDependency.builder()
          .name("spring-web").group("org.springframework").version("5.3.17")
          .versionNumber(CustomVersionNumber.parse("5.3.17"))
          .fixVersionNumber(CustomVersionNumber.parse("6.0.0")).severity(CvssSeverity.CRITICAL)
          .fixVersion("6.0").dependencyName("org.springframework:spring-web").build();

      assertThat(fixableDependencies).isNotEmpty();
      assertThat(fixableDependencies).contains(expectedFixDependency);
      assertThat(fixableDependencies).doesNotContain(expectedFixedByOtherDependency);
      assertThat(fixableDependencies.get(5)).hasNoNullFieldsOrProperties();
      assertThat(fixableDependencies.get(5).nextFixVersion()).isTrue();
//      assertThat(fixableDependencies.get(0).nextFixVersion()).isFalse();
      assertThat(fixedByOtherDependencies).isNotEmpty();
      assertThat(fixedByOtherDependencies).contains(expectedFixedByOtherDependency);
      assertThat(unfixableDependencies).isNotEmpty();
      assertThat(unfixableDependencies).contains(expectedUnfixDependency);
    }
  }

}
